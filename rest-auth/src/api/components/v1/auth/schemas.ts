import { Schemas } from '@api/lib/validators';
import { registry } from '@api/lib/openapi';
import { z } from '@api/lib/zod';

const loginChallengeParam = registry.registerParameter(
  'LoginChallenge',
  z.string().openapi({
    param: {
      name: 'login_challenge',
      description:
        'A required Hydra login challenge. If present, Kratos will cooperate with\nOry Hydra to act as an OAuth2 identity provider.\n\nThe value for this parameter comes from `login_challenge` URL Query parameter sent to your\napplication (e.g. `/login?login_challenge=abcde`).',
      in: 'query',
    },
    example: '1212121',
  })
);

/**
 * GET /api/v1/auth/login
 */
const loginSchema = z.object({
  login_challenge: loginChallengeParam,
});

const loginSchemaResponse = z
  .object({
    flowId: z.string().openapi({ description: 'Id of flow generated by ory kratos' }),
    ui: z.object({
      csrf_token: z.string().openapi({ description: 'Token generated to prevent csrf attacks' }),
    }),
  })
  .openapi('loginSchemaResponse');

/**
 * GET /api/v1/auth/consent
 */
const redirectSchemaResponse = z.object({
  redirect_to: z.string(),
});

const redirectSchemaResponseWithError = z.object({
  error: z.object({
    id: z.literal('browser_location_change_required'),
    code: z.literal(422),
    reason: z.string(),
  }),
  redirect_browser_to: z.string(),
});
const acceptConsentRequetSchema = z.object({
  consent_challenge: z.string().openapi({
    param: {
      name: 'consent_challenge',
      description: 'consent challenge generated by ory kratos',
      in: 'query',
    },
  }),
});

/**
 * GET /api/v1/auth/logout
 */

const schemas = {
  createLoginFlow: {
    request: {
      query: loginSchema,
    },
    response: { 200: loginSchemaResponse },
  },
  updateLoginFlow: {
    request: {
      params: z.object({
        flowId: z.string(),
      }),
      body: z.object({
        csrfToken: z.string(),
        email: z.string(),
        password: z.string(),
      }),
    },
    response: {
      200: z.object({
        session_token: z.string(),
        continue_with: z.array(z.object({ action: z.enum(['redirect_browser_to']) })),
      }),
      422: redirectSchemaResponseWithError,
    },
  },
  acceptConsentRequest: {
    request: {
      query: acceptConsentRequetSchema,
    },
    response: { 200: redirectSchemaResponse },
  },
  logout: {
    request: {
      query: z.object({ logout_challenge: z.coerce.string() }),
    },
    response: { 302: z.object({ Location: z.string() }) },
  },
} satisfies {
  [routeKey: string]: {
    request: Schemas<z.ZodRawShape>;
    response: { [key: number]: z.ZodObject<z.ZodRawShape> };
  };
};

export { schemas };
